import { StorefrontAccessToken, Report, ApplicationCharge, ApplicationCredit, RecurringApplicationCharge, UsageCharge, Customer, CustomerInvite, Address, ShippingAddress, CustomerSavedSearch, DiscountCode, DiscountCodeCreation, PriceRule, Webhook, InventoryLevel, MarketingEvent, Engagement, Metafield, Article, Blog, Comment, Page, Redirect, ScriptTag, Theme, DraftOrder, Order, Amount, Currency, Refund, Risk, Transaction, GiftCard, Collect, CustomCollection, Product, Image, Variant, Collection, Checkout, MobilePlatformApplication, CreditCard, Payment, ResourceFeedback, FulfillmentOrder, CarrierService, Fulfillment, Event, FulfillmentEvent, ReplacementFulfillmentOrder, OriginalFulfillmentOrder, MovedFulfillmentOrder, FulfillmentHold, FulfillmentService, Country } from "./root-types";

export type RecurringApplicationChargeId = number;
export type CustomerId = number;
export type PriceRuleId = number;
export type MarketingEventId = number;
export type BlogId = number;
export type CommentId = number;
export type DraftOrderId = number;
export type OrderId = number;
export type GiftCardId = number;
export type ProductId = number;
export type Token = number;
export type FulfillmentOrderId = number;
export type FulfillmentId = number;


export type PostPaths =
  | {
      /** Creates a new storefront access token  */
      path: `storefront_access_tokens`;
      body: {
        storefront_access_token: Omit<StorefrontAccessToken, "admin_graphql_api_id" | "id" | "access_token" | "access_scope" | "created_at" | "title"> & Required<Pick<StorefrontAccessToken, "title">>;
      };
      response: {
        storefront_access_token: StorefrontAccessToken;
      };
    }
  | {
      /** Creates a new report  */
      path: `reports`;
      query: {
        /** The name of the report. Maximum length: 255 characters. */
        name?: string;
        /** The ShopifyQL the report will query. */
        shopify_ql?: string;
      };
      body: {
        report: Omit<Report, "admin_graphql_api_id">;
      };
      response: {
        report: Report;
      };
    }
  | {
      /** Creates an application charge  */
      path: `application_charges`;
      body: {
        application_charge: Omit<ApplicationCharge, "admin_graphql_api_id">;
      };
      response: {
        application_charge: ApplicationCharge;
      };
    }
  | {
      /** Creates an application credit  */
      path: `application_credits`;
      body: {
        application_credit: Omit<ApplicationCredit, "admin_graphql_api_id">;
      };
      response: {
        application_credit: ApplicationCredit;
      };
    }
  | {
      /** Creates a recurring application charge  */
      path: `recurring_application_charges`;
      body: {
        recurring_application_charge: Omit<RecurringApplicationCharge, "admin_graphql_api_id">;
      };
      response: {
        recurring_application_charge: RecurringApplicationCharge;
      };
    }
  | {
      /** Creates a usage charge  */
      path: `recurring_application_charges/${RecurringApplicationChargeId}/usage_charges`;
      body: {
        usage_charge: Omit<UsageCharge, "admin_graphql_api_id">;
      };
      response: {
        usage_charge: UsageCharge;
      };
    }
  | {
      /** Creates a customer.  */
      path: `customers`;
      body: {
        customer: Omit<Customer, "admin_graphql_api_id" | "currency" | "created_at" | "default_address" | "last_order_id" | "last_order_name" | "orders_count" | "state" | "total_spent" | "updated_at" | "verified_email">;
      };
      response: {
        customer: Customer;
      };
    }
  | {
      /** Generate an account activation URL for a customer whose account is not yet enabled. This is useful when you've imported a large number of customers and want to send them activation emails all at once. Using this approach, you'll need to generate and send the activation emails yourself.
      The account activation URL generated by this endpoint is for one-time use and will expire after 30 days. If you make a new POST request to this endpoint, then a new URL will be generated. The new URL will be again valid for 30 days, but the previous URL will no longer be valid.  */
      path: `customers/${CustomerId}/account_activation_url`;
      response: {
        account_activation_url?: string;
      };
    }
  | {
      /** Sends an account invite to a customer.  */
      path: `customers/${CustomerId}/send_invite`;
      body: {
        customer_invite: CustomerInvite;
      };
      response: {
        customer_invite: CustomerInvite;
      };
    }
  | {
      /** Creates a new address for a customer.  */
      path: `customers/${CustomerId}/addresses`;
      body: {
        address: Address;
      };
      response: {
        customer_address: ShippingAddress;
      };
    }
  | {
      /** Creates a customer saved search.  */
      path: `customer_saved_searches`;
      body: {
        customer_saved_search: Omit<CustomerSavedSearch, "admin_graphql_api_id" | "created_at" | "id" | "updated_at">;
      };
      response: {
        customer_saved_search: CustomerSavedSearch;
      };
    }
  | {
      /** Creates a discount code  */
      path: `price_rules/${PriceRuleId}/discount_codes`;
      body: {
        discount_code: Omit<DiscountCode, "admin_graphql_api_id" | "created_at" | "updated_at" | "id" | "price_rule_id" | "usage_count" | "code"> & Required<Pick<DiscountCode, "code">>;
      };
      response: {
        discount_code: DiscountCode;
      };
    }
  | {
      /** Creates a discount code creation job.
      The batch endpoint can be used to asynchronously create up to 100 discount codes in a single request. It
      enqueues and returns a discount_code_creation object that can be monitored for completion.
      You can enqueue a single creation job per a shop and you can't enqueue more until the job completes.
      Response fields that are specific to the batch endpoint include:
      status: The state of the discount code creation job. Possible values are:
      queued: The job is acknowledged, but not started.
      running: The job is in process.
      completed: The job has finished.
      codes_count: The number of discount codes to create.
      imported_count: The number of discount codes created successfully.
      failed_count: The number of discount codes that were not created successfully. Unsuccessful attempts will retry up to three times.
      logs: A report that specifies when no discount codes were created because the provided data was invalid. Example responses:
      "Price rule target selection can't be blank"
      "Price rule allocation method can't be blank"
        */
      path: `price_rules/${PriceRuleId}/batch`;
      body: {
        discount_codes: Omit<DiscountCode, "admin_graphql_api_id" | "created_at" | "updated_at" | "id" | "price_rule_id" | "usage_count" | "code"> & Required<Pick<DiscountCode, "code">>;
      };
      response: {
        discount_code_creation: DiscountCodeCreation;
      };
    }
  | {
      /** Creates a price rule  */
      path: `price_rules`;
      body: {
        price_rule: Omit<PriceRule, "admin_graphql_api_id" | "created_at" | "updated_at" | "id">;
      };
      response: {
        price_rule: PriceRule;
      };
    }
  | {
      /** Create a new webhook subscription by specifying both an address and a topic.Amazon EventBridge and Google Pub/Sub webhook subscriptions use this field differently.For more information, refer to the Amazon EventBridgeand Google Cloud Pub/Sub pages.  */
      path: `webhooks`;
      body: {
        webhook: Omit<Webhook, "admin_graphql_api_id" | "api_version" | "created_at" | "id" | "updated_at" | "address" | "topic"> & Required<Pick<Webhook, "address" | "topic">>;
      };
      response: {
        webhook: Webhook;
      };
    }
  | {
      /** Adjusts the inventory level of an inventory item at a single location  */
      path: `inventory_levels/adjust`;
      query: {
        /** The amount to adjust the available inventory quantity. Send negative values to subtract from the current available quantity. For example, "available_adjustment": 2 increases the current available quantity by 2, and "available_adjustment": -3decreases the current available quantity by 3. */
        available_adjustment?: string;
        /** The ID of the inventory item. */
        inventory_item_id?: string;
        /** The ID of the location that the inventory level belongs to. To find the ID of the location, use the Location resource. */
        location_id?: string;
      };
      body: {
        location_id?: number;
        inventory_item_id?: number;
        available_adjustment?: number;
      };
      response: {
        inventory_level: InventoryLevel;
      };
    }
  | {
      /** Connects an inventory item to a location by creating an inventory level at that location.
      When connecting inventory items to locations, it's important to understand the rules around
      fulfillment service locations.  */
      path: `inventory_levels/connect`;
      query: {
        /** The ID of the inventory item. */
        inventory_item_id?: string;
        /** The ID of the location that the inventory level belongs to. To find the ID of the location, use the Location resource. */
        location_id?: string;
        /** Whether inventory for any previously connected locations will be relocated. This property is ignored when no fulfillment service location is involved. For more information, see Inventory levels and fulfillment service locations. */
        relocate_if_necessary?: string;
      };
      body: {
        location_id?: number;
        inventory_item_id?: number;
      };
      response: {
        inventory_level: InventoryLevel;
      };
    }
  | {
      /** Sets the inventory level for an inventory item at a location.
      If the specified location is not connected, it will be automatically connected first.
      When connecting inventory items to locations, it's important to understand the rules around
      fulfillment service locations.  */
      path: `inventory_levels/set`;
      query: {
        /** Sets the available inventory quantity. */
        available?: string;
        /** The ID for the inventory item. */
        inventory_item_id?: string;
        /** The ID of the location that the inventory level belongs to. To find the ID of the location, use the Location resource. */
        location_id?: string;
        /** Whether inventory for any previously connected locations will be set to 0 and the locations disconnected. This property is ignored when no fulfillment service is involved. For more information, see Inventory levels and fulfillment service locations. */
        disconnect_if_necessary?: string;
      };
      body: {
        location_id?: number;
        inventory_item_id?: number;
        available?: number;
      };
      response: {
        inventory_level: InventoryLevel;
      };
    }
  | {
      /** Creates a marketing event  */
      path: `marketing_events`;
      body: {
        marketing_event: Omit<MarketingEvent, "admin_graphql_api_id" | "event_type" | "marketing_channel" | "paid" | "started_at"> & Required<Pick<MarketingEvent, "event_type" | "marketing_channel" | "paid" | "started_at">>;
      };
      response: {
        marketing_event: MarketingEvent;
      };
    }
  | {
      /** Engagements on marketing events represent customer activity taken on the marketing event before customers reach the shop’s website. Not all types of marketing events will necessarily have engagement, and most types of marketing events will only use a subset of the possible engagement types.
      Engagements are aggregated on a daily basis. However, the data can be sent more often than once a day if the information is available. If you create an engagement with the same value for occurred_on as an existing engagement, then the new engagement will overwrite the previous one.  */
      path: `marketing_events/${MarketingEventId}/engagements`;
      query: {
        /** The date that these engagements occurred on, in the format “YYYY-MM-DD”. */
        occurred_on?: string;
        /**      The total ad spend for the day, if the marketing event is a paid ad with a daily spend.  */
        ad_spend?: string;
        /** The total number of clicks on the marketing event for the day. */
        clicks_count?: string;
        /** The total number of comments for the day. */
        comments_count?: string;
        /** The total number of favorites for the day. */
        favorites_count?: string;
        /**      The total number of impressions for the day. An impression occurs when the marketing event is served to a customer, either as a email or through a marketing channel.  */
        impressions_count?: string;
        /**      Whether the engagements are reported as lifetime values rather than daily totals.  */
        is_cumulative?: string;
        /** The total number of shares for the day. */
        shares_count?: string;
        /**      The total number of views for the day. A view occurs when a customer reads the marketing event that was served to them, for example, if the customer opens the email or spends time looking at a Facebook post.  */
        views_count?: string;
      };
      body: {
        engagements: Engagement;
      };
      response: {
        engagements: Engagement;
      };
    }
  | {
      /** Creates a new metafield for a resource.  */
      path: `metafields`;
      body: {
        metafield: Omit<Metafield, "admin_graphql_api_id" | "created_at" | "updated_at" | "id" | "key" | "namespace" | "value"> & Required<Pick<Metafield, "key" | "namespace" | "value">>;
      };
      response: {
        metafield: Metafield;
      };
    }
  | {
      path: `blogs/${BlogId}/articles`;
      body: {
        article: Omit<Article, "admin_graphql_api_id" | "created_at" | "id" | "updated_at" | "user_id">;
      };
      response: {
        article: Article;
      };
    }
  | {
      /** Create a new blog  */
      path: `blogs`;
      body: {
        blog: Omit<Blog, "admin_graphql_api_id" | "created_at" | "id" | "updated_at">;
      };
      response: {
        blog: Blog;
      };
    }
  | {
      /** Creates a comment for an article  */
      path: `comments`;
      body: {
        comment: Omit<Comment, "admin_graphql_api_id" | "created_at" | "id" | "status" | "updated_at">;
      };
      response: {
        comment: Comment;
      };
    }
  | {
      /** Marks a comment as spam  */
      path: `comments/${CommentId}/spam`;
      response: {
        published_at?: Date;
        status?: string;
        id?: number;
        body?: string;
        body_html?: string;
        author?: string;
        email?: string;
        article_id?: number;
        blog_id?: number;
        created_at?: Date;
        updated_at?: Date;
        ip?: string;
        user_agent?: string;
      };
    }
  | {
      /** Marks a comment as not spam  */
      path: `comments/${CommentId}/not_spam`;
      response: {
        published_at?: Date;
        status?: string;
        id?: number;
        body?: string;
        body_html?: string;
        author?: string;
        email?: string;
        article_id?: number;
        blog_id?: number;
        created_at?: Date;
        updated_at?: Date;
        ip?: string;
        user_agent?: string;
      };
    }
  | {
      /** Approves a comment  */
      path: `comments/${CommentId}/approve`;
      response: {
        published_at?: Date;
        status?: string;
        id?: number;
        body?: string;
        body_html?: string;
        author?: string;
        email?: string;
        article_id?: number;
        blog_id?: number;
        created_at?: Date;
        updated_at?: Date;
        ip?: string;
        user_agent?: string;
      };
    }
  | {
      /** Removes a comment  */
      path: `comments/${CommentId}/remove`;
      response: {
        published_at?: Date;
        status?: string;
        id?: number;
        body?: string;
        body_html?: string;
        author?: string;
        email?: string;
        article_id?: number;
        blog_id?: number;
        created_at?: Date;
        updated_at?: Date;
        ip?: string;
        user_agent?: string;
      };
    }
  | {
      /** Restores a previously removed comment  */
      path: `comments/${CommentId}/restore`;
      response: {
        published_at?: Date;
        status?: string;
        id?: number;
        body?: string;
        body_html?: string;
        author?: string;
        email?: string;
        article_id?: number;
        blog_id?: number;
        created_at?: Date;
        updated_at?: Date;
        ip?: string;
        user_agent?: string;
      };
    }
  | {
      /** Creates a page.  */
      path: `pages`;
      body: {
        page: Omit<Page, "admin_graphql_api_id" | "created_at" | "id" | "shop_id" | "updated_at">;
      };
      response: {
        page: Page;
      };
    }
  | {
      /** Creates a redirect. When you provide a full URL as the value of the path property, it will be saved as an absolute path without the domain.
      For example, "path": "http://www.johns-apparel.com/springwear" will be saved as "path": "springwear".  */
      path: `redirects`;
      body: {
        redirect: Omit<Redirect, "admin_graphql_api_id" | "id">;
      };
      response: {
        redirect: Redirect;
      };
    }
  | {
      /** Creates a new script tag  */
      path: `script_tags`;
      body: {
        script_tag: Omit<ScriptTag, "admin_graphql_api_id" | "created_at" | "id" | "updated_at" | "event" | "src"> & Required<Pick<ScriptTag, "event" | "src">>;
      };
      response: {
        script_tag: ScriptTag;
      };
    }
  | {
      /** Creates a theme by providing the public URL of a ZIP file that contains the theme.
      A new theme is always unpublished by default. To publish a theme when you create it, include
      "role": "main" in the POST request. The theme will be published only after all
      of its files have been extracted and stored by Shopify, which might take a couple of minutes.  */
      path: `themes`;
      body: {
        theme: Omit<Theme, "admin_graphql_api_id" | "created_at" | "id" | "previewable" | "processing" | "theme_store_id" | "updated_at">;
      };
      response: {
        theme: Theme;
      };
    }
  | {
      /** Creates a draft order.
      Using the DraftOrder resource you can create orders in draft state using product variant line items,
      or custom line items. To create a product variant draft order, provide the variant_id, quantity and discount properties. To create a custom line item, provide the title, price, taxable,
      and quantity properties.
      Note
      If you are using this endpoint with a Partner development store or a trial store, then you can only create five draft orders per minute.
      Polling
      When you create and update draft orders some calculations are done asynchronously, such as calculating shipping and taxes. There might be times when a draft order is created but these calculations haven't completed. In these cases, you need to poll the draft order until the calculations are finished.
      When a draft order requires polling, a 202 accepted response code is returned along with location and retry-after response headers. The location header refers to the URL to be polled, and retry-after denotes the interval (in seconds) at which polling requests should be sent. When the draft order is ready, a 200 OK response code will be returned.
      About custom shipping lines
      You can use the DraftOrder resource to send orders with custom shipping lines.
      A custom shipping line includes a title and price with handle
      set to Nil. A shipping line with a carrier provided shipping rate
      (currently set via the Shopify admin) includes the shipping rate handle.
      Applying discounts
      A draft order and its line items can have one discount each. Calculations for discounts are based on the setting
      of the value_type property, which can be set to either fixed_amount or percentage.
      For example, you can apply a fixed amount discount to a draft order to reduce the price by the specified value property.
      When you use a percentage discount, the discount amount property is the price multiplied by the value property.
      For line item discounts, the value property is applied per individual unit of the item, based on the line item's quantity.
      Calculating line item discount amounts
      For fixed_amount discounts, the total amount corresponds to the line item quantity
      times the value of the discount.
      For percentage discounts, the total amount corresponds to the following:
      amount = floor(price * quantity * value) / 100, where floor() is the usual round down function.
      For non-fractional currencies, this formula needs to use round() instead of floor(), and the division by 100 takes place inside the rounding, resulting in a non-fractional value.
      Otherwise, an error is returned.
      amount = round(price * quantity * value / 100)
      Line item examples
      Fixed amount discount
      For a $19.99 line item with quantity of 2 and with $5 dollars off,
      discount amount corresponds to $10 ($5 * 2):
      applied_discount: { "value_type": "fixed_amount", "value": 5, "amount": 10 }
      For a fixed amount example, see Create a draft order with a discount.
      Percentage discount
      For a $19.99 line item with quantity of 2 and with 15% off,
      discount amount corresponds to $5.99 (floor ($19.99 * 2 * 15) / 100):
      applied_discount: { "value_type": "percentage", "value": 15, "amount": 5.99 }
      For a percentage example, see Create a percent discount on a line item.
      Loading and removing customers
      You can load a customer to a draft order by sending the customer_id as part of the draft order object. The recommended way to remove a customer from a draft order is to make a POST request with the Customer object set to null,
      without specifying an email, shipping address, or billing address.
      A customer may also be removed by setting customer, email, shipping_address, and billing_address to null.
        */
      path: `draft_orders`;
      query: {
        /** Used to load the customer. When a customer is loaded, the customer’s email address is also associated. */
        customer_id?: string;
        /** An optional boolean that you can send as part of a draft order object     to load customer shipping information. Valid values: true or false. */
        use_customer_default_address?: string;
      };
      body: {
        draft_order: Omit<DraftOrder, "admin_graphql_api_id" | "payment_terms">;
      };
      response: {
        draft_order: DraftOrder;
      };
    }
  | {
      /** Sends an invoice for the draft order.
      You can include the following parameters in the body of the request:
      draft_order_invoice: The object to send in the body of the request.
      to: The email address that will populate the to field of the email.
      from: The email address that will populate the from field of the email.
      bcc: The list of email addresses to include in the bcc field of the email. Emails must be associated with staff accounts on the shop.
      subject: The email subject.
      custom_message: The custom message displayed in the email.
        */
      path: `draft_orders/${DraftOrderId}/send_invoice`;
      body: {
        draft_order_invoice: CustomerInvite;
      };
      response: {
        draft_order_invoice: CustomerInvite;
      };
    }
  | {
      /** Creates an order.
      By default, product inventory is not claimed when creating an order.
      There are additional optional parameters that can be specified in the body of the request when creating an order:
      inventory_behaviour: The behaviour to use when updating inventory. (default: bypass)
      bypass: Do not claim inventory.
      decrement_ignoring_policy: Ignore the product's inventory policy and claim inventory.
      decrement_obeying_policy: Follow the product's inventory policy and claim inventory, if possible.
      send_receipt: Whether to send an order confirmation to the customer. (default: `false`)
      Note
      If you're working on a private app and order confirmations are still being sent to the customer when send_receipt is set to false, then you need to disable the Storefront API from the private app's page in the Shopify admin.
      send_fulfillment_receipt: Whether to send a shipping confirmation to the customer. (default: `false`)
      Note
      If you are including shipping_address or billing_address, make sure to pass both
      first_name and last_name. Otherwise both these addresses will be ignored.
      Usage notes: If you're using this endpoint with a trial or Partner development store, then you can create no more than 5 new orders per minute.
        */
      path: `orders`;
      body: {
        order: Omit<Order, "admin_graphql_api_id" | "app_id" | "browser_ip" | "cancelled_at" | "cart_token" | "checkout_token" | "client_details" | "closed_at" | "created_at" | "currency" | "current_total_discounts" | "current_total_discounts_set" | "current_total_duties_set" | "current_total_price" | "current_total_price_set" | "current_subtotal_price" | "current_subtotal_price_set" | "current_total_tax" | "current_total_tax_set" | "customer_locale" | "discount_applications" | "id" | "landing_site" | "number" | "order_number" | "original_total_duties_set" | "payment_terms" | "payment_gateway_names" | "processing_method" | "refunds" | "test" | "token" | "total_tip_received" | "updated_at" | "order_status_url" | "line_items"> & Required<Pick<Order, "line_items">>;
      };
      response: {
        order: Order;
      };
    }
  | {
      /** Closes an order. A closed order is one that has no more work to be done. All items have been fulfilled or refunded.  */
      path: `orders/${OrderId}/close`;
      response: {
        order: Order;
      };
    }
  | {
      /** Re-opens a closed order  */
      path: `orders/${OrderId}/open`;
      response: {
        order: Order;
      };
    }
  | {
      /** 
      Caution
      For multi-currency orders, the currency property is required whenever the amount property is provided. For more information, see Migrating to support multiple currencies.
      Cancels an order. Orders that are paid and have fulfillments can't be canceled.  */
      path: `orders/${OrderId}/cancel`;
      query: {
        /** The amount to refund. If set, Shopify attempts to refund the specified amount, depending on its status. Shopify refunds through a manual gateway in cases where the original transaction was not made in Shopify. Refunds through a manual gateway are recorded as a refund on Shopify, but the customer is not refunded. */
        amount?: string;
        /** The currency of the refund that's issued when the order is canceled. Required for multi-currency orders whenever the amount property is provided. */
        currency?: string;
        /** Whether to send an email to the customer notifying them of the cancellation. */
        email?: string;
        /** The reason for the order cancellation. Valid values: customer, inventory, fraud, declined, and other.) */
        reason?: string;
        /** The refund transactions to perform. Required for some more complex refund situations. For more information, see the Refund API. */
        refund?: string;
        /** Whether to restock refunded items back to your store's inventory. */
        restock?: string;
      };
      body: {
        amount: Amount;
        currency: Currency;
        refund: Refund;
      };
      response: {
        order: Order;
        notice?: string;
      };
    }
  | {
      /** Creates an order risk for an order  */
      path: `orders/${OrderId}/risks`;
      body: {
        risk: Omit<Risk, "admin_graphql_api_id">;
      };
      response: {
        risk: Risk;
      };
    }
  | {
      /** 
      Caution
      For multi-currency orders, the currency property is required whenever the amount property is provided. For more information, see Migrating to support multiple currencies.
      Creates a refund. Use the calculate endpoint to produce the transactions to submit.
      Note
      When you use this endpoint with a Partner development store or a trial store, you can create only five refunds per minute.
        */
      path: `orders/${OrderId}/refunds`;
      query: {
        /**     The three-letter code (ISO 4217 format) for the currency used for the refund.  */
        currency?: string;
        /** An optional comment that explains a discrepancy between calculated and actual refund amounts. Used to populate the reason property of the resulting order adjustment object attached to the refund. Valid values: restock, damage, customer, and other. */
        discrepancy_reason?: string;
        /** An optional note attached to a refund. */
        note?: string;
        /** Whether to send a refund notification to the customer. */
        notify?: string;
        /** A list of line item IDs, quantities to refund, and restock instructions. Each entry has the following properties: */
        refund_line_items?: string;
        /** Whether to add the line items back to the store inventory. Use restock_type for refund line items instead. */
        restock?: string;
        /** Specify how much shipping to refund. It has the following properties: */
        shipping?: string;
        /**      A list of transactions      to process as refunds.  */
        transactions?: string;
      };
      body: {
        refund: Omit<Refund, "admin_graphql_api_id" | "created_at" | "duties" | "id" | "order_adjustments">;
      };
      response: {
        refund: Refund;
      };
    }
  | {
      /** 
      Caution
      For multi-currency orders, the currency property is required whenever the amount property is provided. For more information, see Migrating to support multiple currencies.
      Calculates refund transactions based on line items and shipping. When you want to create a refund,
      you should first use the calculate endpoint to generate accurate refund transactions. Specify the line items
      that are being refunded, their quantity and restock instructions, and whether you intend to refund
      shipping costs. If the restock instructions can't be met—for example, because you try to return more items than have been
      fulfilled—then the endpoint returns modified restock instructions. You can then use the response in the body of the request to create the actual refund.
      The response includes a transactions object with "kind": "suggested_refund",
      which must to be changed to "kind" : "refund" for the refund to be accepted.  */
      path: `orders/${OrderId}/refunds/calculate`;
      query: {
        /**      The three-letter code (ISO 4217 format) for the      currency used for the refund. Note: Required whenever the shipping amount property is provided.   */
        currency?: string;
        /** A list of line item IDs, quantities to refund, and restock instructions. Each entry has the following properties: */
        refund_line_items?: string;
        /** Specify how much shipping to refund. It has the following properties: */
        shipping?: string;
      };
      body: {
        refund: Omit<Refund, "admin_graphql_api_id" | "created_at" | "duties" | "id" | "order_adjustments">;
      };
      response: {
        refund: Refund;
      };
    }
  | {
      /** 
      Caution
      For multi-currency orders, the currency property is required when creating refund and capture transactions. The value should be the presentment currency from the order. For more information, see Migrating to support multiple currencies.
      Creates a transaction for an order.  */
      path: `orders/${OrderId}/transactions`;
      query: {
        /** The origin of the transaction. Set to external to create a cash transaction for the associated order. */
        source?: string;
      };
      body: {
        transaction: Omit<Transaction, "admin_graphql_api_id" | "created_at" | "device_id" | "error_code" | "id" | "location_id" | "message" | "payment_details" | "receipt" | "source_name" | "kind"> & Required<Pick<Transaction, "kind">>;
      };
      response: {
        transaction: Transaction;
      };
    }
  | {
      /** Creates a gift card  */
      path: `gift_cards`;
      body: {
        gift_card: Omit<GiftCard, "admin_graphql_api_id">;
      };
      response: {
        gift_card: GiftCard;
      };
    }
  | {
      /** Disables a gift card. Disabling a gift card can't be undone.  */
      path: `gift_cards/${GiftCardId}/disable`;
      body: {
        gift_card: Omit<GiftCard, "admin_graphql_api_id">;
      };
      response: {
        gift_card: GiftCard;
      };
    }
  | {
      /** Adds a product to a custom collection.  */
      path: `collects`;
      body: {
        collect: Omit<Collect, "admin_graphql_api_id">;
      };
      response: {
        collect: Collect;
      };
    }
  | {
      /** Creates a custom collection  */
      path: `custom_collections`;
      body: {
        custom_collection: Omit<CustomCollection, "admin_graphql_api_id" | "id" | "published_at" | "published_scope" | "updated_at" | "title"> & Required<Pick<CustomCollection, "title">>;
      };
      response: {
        custom_collection: CustomCollection;
      };
    }
  | {
      /** Create a new product.  */
      path: `products`;
      body: {
        product: Omit<Product, "admin_graphql_api_id" | "created_at" | "id" | "updated_at" | "title"> & Required<Pick<Product, "title">>;
      };
      response: {
        product: Product;
      };
    }
  | {
      /** Create a new product image  */
      path: `products/${ProductId}/images`;
      body: {
        image: Omit<Image, "admin_graphql_api_id">;
      };
      response: {
        image: Image;
      };
    }
  | {
      /** Creates a new product variant  */
      path: `products/${ProductId}/variants`;
      body: {
        variant: Omit<Variant, "admin_graphql_api_id" | "inventory_quantity" | "presentment_prices" | "position" | "title">;
      };
      response: {
        variant: Variant;
      };
    }
  | {
      /** Creates a new smart collection using the specified rules.  */
      path: `smart_collections`;
      body: {
        smart_collection: Omit<Collection, "admin_graphql_api_id" | "updated_at" | "rules" | "title"> & Required<Pick<Collection, "rules" | "title">>;
      };
      response: {
        smart_collection: Collection;
      };
    }
  | {
      /** Creates a checkout  */
      path: `checkouts`;
      body: {
        checkout: Omit<Checkout, "admin_graphql_api_id" | "created_at" | "currency" | "order" | "payment_due" | "payment_url" | "requires_shipping" | "shipping_rate" | "subtotal_price" | "tax_lines" | "taxes_included" | "token" | "total_price" | "total_tax" | "updated_at" | "web_url" | "billing_address" | "line_items"> & Required<Pick<Checkout, "billing_address" | "line_items">>;
      };
      response: {
        checkout: Checkout;
      };
    }
  | {
      /** Completes a checkout  */
      path: `checkouts/${Token}/complete`;
      response: {
        checkout: Checkout;
      };
    }
  | {
      /** Create a mobile platform application  */
      path: `mobile_platform_applications`;
      body: {
        mobile_platform_application: Omit<MobilePlatformApplication, "admin_graphql_api_id">;
      };
      response: {
        mobile_platform_application: MobilePlatformApplication;
      };
    }
  | {
      /** Stores a credit card in the card vault. Credit cards cannot be sent to the Checkout API directly. They must be
      sent to the card vault, which in response will return a session ID. This session ID can then be used when
      calling the POST #{token}/payments.json endpoint. A session ID is valid only for a single call to the endpoint.
      The card vault has a static URL and is located at https://elb.deposit.shopifycs.com/sessions.
      It is also provided via the payment_url property on the
      Checkout resource.  */
      path: `https://elb.deposit.shopifycs.com/sessions`;
      query: {
        /** The credit card used for payment. See the properties table above for a description of its attributes. */
        credit_card?: string;
      };
      body: {
        credit_card: CreditCard;
      };
      response: {
        id?: number;
      };
    }
  | {
      /** Creates a payment on a checkout using the session ID returned by the card vault  */
      path: `checkouts/${Token}/payments`;
      query: {
        /** The amount of the payment. */
        amount?: string;
        /** The details of the request, including the following attributes: */
        request_details?: string;
        /** A session ID provided by the card vault when creating a payment session. */
        session_id?: string;
        /** A unique idempotency token generated by your app. This can be any value, but must be unique across all payment requests. */
        unique_token?: string;
      };
      body: {
        payment: Omit<Payment, "admin_graphql_api_id">;
      };
      response: {
        payment: Payment;
      };
    }
  | {
      /** Create product feedback.  */
      path: `products/${ProductId}/resource_feedback`;
      query: {
        /** Create feedback for a specific product, using its product id. */
        product_id?: string;
        state?: string;
      };
      body: {
        resource_feedback: Omit<ResourceFeedback, "admin_graphql_api_id">;
      };
      response: {
        resource_feedback: ResourceFeedback;
      };
    }
  | {
      /** Creates shop resource feedback.  */
      path: `resource_feedback`;
      query: {
        /** An ISO 8601 date and time indicating when the feedback was generated by your app. */
        feedback_generated_at?: string;
        /** An array containing a single message. See Formatting the resource feedback message field for formatting requirements.  */
        messages?: string;
        /** Must be one of the following values: */
        state?: string;
      };
      body: {
        resource_feedback: Omit<ResourceFeedback, "admin_graphql_api_id" | "created_at" | "updated_at" | "resource_id" | "resource_type">;
      };
      response: {
        resource_feedback: ResourceFeedback;
      };
    }
  | {
      /** Sends a cancellation request to the fulfillment service of a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/cancellation_request`;
      query: {
        /** An optional reason for the cancellation request. */
        message?: string;
      };
      body: {
        cancellation_request?: {};
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Accepts a cancellation request sent to a fulfillment service for a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/cancellation_request/accept`;
      query: {
        /** An optional reason for accepting the cancellation request. */
        message?: string;
      };
      body: {
        cancellation_request?: {};
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Rejects a cancellation request sent to a fulfillment service for a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/cancellation_request/reject`;
      query: {
        /** An optional reason for rejecting the cancellation request. */
        message?: string;
      };
      body: {
        cancellation_request?: {};
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Creates a carrier service  */
      path: `carrier_services`;
      body: {
        carrier_service: Omit<CarrierService, "admin_graphql_api_id">;
      };
      response: {
        carrier_service: CarrierService;
      };
    }
  | {
      /** Create a fulfillment for the specified order and line items.
      The fulfillment's status depends on the line items in the order:
      If the line items in the fulfillment use a manual or custom fulfillment service, then the status of the returned fulfillment will be set immediately.
      If the line items use an external fulfillment service, then they will be queued for fulfillment and the status will be set to pending until the external fulfillment service has been invoked.
      A fulfillment might then transition to open, which implies it is being processed by the service, before transitioning to success when the items have shipped.
      If you don't specify line item IDs, then all unfulfilled and partially fulfilled line items for the order will be fulfilled.
      However, if an order is refunded or if any of its individual line items are refunded, then the order can't be fulfilled.
      All line items being fulfilled must have the same fulfillment service.
      Note
      If you are using this endpoint with a Partner development store or a trial store, then you can create no more than 5 new fulfillments per minute.
      About tracking urls
      If you're creating a fulfillment for a supported carrier, then you can send the tracking_company and tracking_numbers fields, and Shopify will generate the tracking_url for you. If you're creating a fulfillment for an unsupported carrier (not in the tracking_company list), then send the tracking_company, tracking_numbers, and tracking_urls fields.
      Note
      If you send an unsupported carrier without a tracking URL, then Shopify will still try to generate a valid tracking URL by using pattern matching on the tracking number. However, Shopify does not validate the tracking URL, so you should make sure that your tracking URL is correct for the order and fulfillment.
        */
      path: `orders/${OrderId}/fulfillments`;
      body: {
        fulfillment: Omit<Fulfillment, "admin_graphql_api_id">;
      };
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Creates a fulfillment for one or many fulfillment orders. The fulfillment orders are associated with the same order and are assigned to the same location.  */
      path: `fulfillments`;
      body: {
        fulfillment: Omit<Fulfillment, "admin_graphql_api_id">;
      };
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Updates the tracking information for a fulfillment.  */
      path: `fulfillments/${FulfillmentId}/update_tracking`;
      body: {
        fulfillment: Omit<Fulfillment, "admin_graphql_api_id">;
      };
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Mark a fulfillment as complete  */
      path: `orders/${OrderId}/fulfillments/${FulfillmentId}/complete`;
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Mark a fulfillment as open  */
      path: `orders/${OrderId}/fulfillments/${FulfillmentId}/open`;
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Cancel a fulfillment for a specific order ID  */
      path: `orders/${OrderId}/fulfillments/${FulfillmentId}/cancel`;
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Cancels a fulfillment.  */
      path: `fulfillments/${FulfillmentId}/cancel`;
      response: {
        fulfillment: Fulfillment;
      };
    }
  | {
      /** Creates a fulfillment event  */
      path: `orders/${OrderId}/fulfillments/${FulfillmentId}/events`;
      body: {
        event: Event;
      };
      response: {
        fulfillment_event: FulfillmentEvent;
      };
    }
  | {
      /** Marks a fulfillment order as cancelled.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/cancel`;
      response: {
        fulfillment_order: FulfillmentOrder;
        replacement_fulfillment_order: ReplacementFulfillmentOrder;
      };
    }
  | {
      /** Marks an in progress fulfillment order as incomplete, indicating the fulfillment service
      is unable to ship any remaining items and intends to close the fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/close`;
      query: {
        /** An optional reason for marking the fulfillment order as incomplete. */
        message?: string;
      };
      body: {
        fulfillment_order: Omit<FulfillmentOrder, "admin_graphql_api_id">;
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Moves a fulfillment order from one merchant managed location to another merchant managed location.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/move`;
      query: {
        /** The id of the location to which the fulfillment order will be moved. */
        new_location_id?: string;
      };
      body: {
        fulfillment_order: Omit<FulfillmentOrder, "admin_graphql_api_id">;
      };
      response: {
        original_fulfillment_order: OriginalFulfillmentOrder;
        moved_fulfillment_order: MovedFulfillmentOrder;
        remaining_fulfillment_order?: any;
      };
    }
  | {
      /** Marks a scheduled fulfillment order as ready for fulfillment.
      This endpoint allows merchants to work on a scheduled fulfillment order before its expected fulfill_at datetime.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/open`;
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Updates the fulfill_at time of a scheduled fulfillment order.
      This endpoint is used to manage the time a scheduled fulfillment order will be marked as ready for fulfillment.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/reschedule`;
      body: {
        fulfillment_order: Omit<FulfillmentOrder, "admin_graphql_api_id">;
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Halts all fulfillment work on a fulfillment order with status = OPEN
      and changes the status of the fulfillment order to ON_HOLD.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/hold`;
      query: {
        /** Whether the merchant should receive a notification about the fulfillment hold. If set to true, then the merchant will be notified on the Shopify mobile app (if they use it to manage their store). The default value is false. */
        notify_merchant?: string;
        /** A mandatory reason for the fulfillment hold. */
        reason?: string;
        /** Optional additional information about the fulfillment hold reason. */
        reason_notes?: string;
      };
      body: {
        fulfillment_hold: FulfillmentHold;
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Release the fulfillment hold on a fulfillment order and changes the status
      of the fulfillment order to OPEN or SCHEDULED  */
      path: `fulfillment_orders/${FulfillmentOrderId}/release_hold`;
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Sends a fulfillment request to the fulfillment service of a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/fulfillment_request`;
      query: {
        /** The fulfillment order line items to be requested for fulfillment. If left blank, all line items of the fulfillment order are requested for fulfillment. */
        fulfillment_order_line_items?: string;
        /** An optional message for the fulfillment request. */
        message?: string;
      };
      body: {
        fulfillment_request?: {
          message: string;
          fulfillment_order_line_items: { id: number; quantity: number }[];
        };
      };
      response: {
        original_fulfillment_order: OriginalFulfillmentOrder;
        submitted_fulfillment_order: MovedFulfillmentOrder;
        unsubmitted_fulfillment_order: ReplacementFulfillmentOrder;
      };
    }
  | {
      /** Accepts a fulfillment request sent to a fulfillment service for a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/fulfillment_request/accept`;
      query: {
        /** An optional reason for accepting the fulfillment request. */
        message?: string;
      };
      body: {
        fulfillment_request?: {
          message: string;
          fulfillment_order_line_items: { id: number; quantity: number }[];
        };
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** Rejects a fulfillment request sent to a fulfillment service for a fulfillment order.  */
      path: `fulfillment_orders/${FulfillmentOrderId}/fulfillment_request/reject`;
      query: {
        /** An optional reason for rejecting the fulfillment request. */
        message?: string;
      };
      body: {
        fulfillment_request?: {
          message: string;
          fulfillment_order_line_items: { id: number; quantity: number }[];
        };
      };
      response: {
        fulfillment_order: FulfillmentOrder;
      };
    }
  | {
      /** To create a fulfillment service, you can also send a cURL request with the fulfillment_service.json payload:
      {% highlight html %}
      curl -X POST -d @fulfillment_service.json -H"Accept:application/json" -H"Content-Type:application/json" -H"X-Shopify-Access-Token:{token}" https://{shop}.myshopify.com/admin/fulfillment_services
      {% endhighlight %}
      Replace {token} with the OAuth token given to you by Shopify and https://{shop}.myshopify.com/admin/fulfillment_services with your store's URL.  */
      path: `fulfillment_services`;
      body: {
        fulfillment_service: Omit<FulfillmentService, "admin_graphql_api_id">;
      };
      response: {
        fulfillment_service: FulfillmentService;
      };
    }
  | {
      /** 
      Caution
      As of version 2020-10, the tax field is deprecated.
      Creates a country.  */
      path: `countries`;
      body: {
        country: Omit<Country, "admin_graphql_api_id">;
      };
      response: {
        country: Country;
      };
    }
